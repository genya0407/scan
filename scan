#! /usr/bin/env ruby

require 'optparse'
require 'stringio'

class Format
  def self.build(template_string)
    self.new(template_string)
  end

  def initialize(template_string)
    @template_string = template_string
    @captures = @template_string.scan(/\{(.+?)\}/).flatten.uniq
  end

  def render(params)
    params = params.map { |k,v| [k.to_s, v] }.to_h # convert key to string
    result = @template_string.dup
    @captures.each do |capture|
      result.gsub!("{#{capture}}", params[capture])
    end
    result
  end
end

class Scanner
  attr_accessor :matcher, :output_format

  def self.build(args: ARGV, format_builder: Format)
    regex = nil
    delimiter = nil
    parser = OptionParser.new do |opts|
      opts.on('-p [PATTERN]', 'specify regexp') do |passed_regex|
        regex = passed_regex
      end
      opts.on('-d [DELIMITER]', 'specify delimiter') do |passed_delimiter|
        delimiter = passed_delimiter
      end
    end

    output_format = format_builder.build(parser.parse(args).join(' '))
    matcher = if regex
                RegexpMatcher.new(regexp: Regexp.compile(regex))
              elsif delimiter
                DelimiterMatcher.new(delimiter: delimiter)
              else
                DelimiterMatcher.new(delimiter: '\s+')
              end

    Scanner.new(matcher: matcher, output_format: output_format)
  end

  def initialize(matcher:, output_format:)
    self.matcher = matcher
    self.output_format = output_format
  end

  def scan(reader: $stdin, writer: $stdout)
    output = StringIO.new
    reader
      .readlines(chomp: true)
      .each do |line|
          matched_data = matcher.match(line)
          next unless matched_data
          text = output_format.render(matched_data)
          output.puts(text)
        end
    writer.puts(output.string)
  end
end

class DelimiterMatcher
  def initialize(delimiter:)
    @delimiter_regex = Regexp.compile delimiter
  end

  def match(line)
    format_params = {}
    [line, *line.split(@delimiter_regex)].each.with_index do |capture, index|
      format_params[index] = capture
    end
    format_params
  end
end

class RegexpMatcher
  def initialize(regexp:)
    @regexp = regexp
  end

  def match(line)
    matched_data = @regexp.match(line)
    return unless matched_data
    format_params = {}
    matched_data.to_a.each.with_index do |capture, index|
      format_params[index] = capture
    end
    format_params.merge!(matched_data.named_captures)
  end
end

if __FILE__ == $0
  require 'stackprof'

  StackProf.run(mode: :cpu, out: 'tmp/stackprof-cpu-myapp.dump', interval: 100) do
    Scanner.build.scan
  end
end
